
\begin{frame}{OpenCV}
    \begin{itemize}
        \item OpenCV est une bibliotheque de gestion des images codée en C++ avec une version python qui offrent tant des méthodes de chargement, transformation, manipulation et analyses d'images.
        \item Les images sont traités avec des tableaux numpy.
        \item La documentation est principalement orientée pour les programmeurs C++
        \item OpenCV propose également de nombreuses méthodes pour le traitement de la vidéo.
    \end{itemize}
\end{frame}

\begin{frame}{Particularité de OpenCV}
    Pour des raisons historiques, OpenCV traite et encode les images au format \alert{BGR}.

    La plupart des méthodes capable de traiter les images avec plusieurs canaux doivent donc généralement fournies dans ce format.

    \begin{center}
        \textit{Soyez vigilant, si vous travaillez avec d'autres libraires de manipulation d'images, pensez à vérifier le format de données utilisé}
    \end{center}

\end{frame}

\begin{frame}{Exemple de chargement et d'affichage d'une image en utilisant OpenCV}
    \mintedcustomcode{python/image/opencv-open}{pycon}
    \vfill
    \alert{Note pour les TPs} : \texttt{cv2.imshow} ne fonctionne pas dans google colab.
\end{frame}

\begin{frame}{Exemple de sauvegarde}
    \mintedcustomcode{python/image/opencv-save}{pycon}
\end{frame}

\begin{frame}{Conversion d'une image d'un format de couleur à un autre}
    \mintedcustomcode{python/image/opencv-color}{pycon}
    
    Il existe évidemment une attribut pour chaque convertion de couleur.
\end{frame}

\begin{frame}{Exemple de filtrage d'une image en utilisant OpenCV}
    OpenCV laisse définir la taille de la fenêtre de convolution pour appliquer un filtre donné
    \mintedcustomcode{python/image/opencv-gaussianblur}{pycon}

    \V{"img/ravens-gaussian" | image("tw", 0.35)}
\end{frame}

\begin{frame}{Transformation}
    Les transformations du type décalage et rotations sont toutes effectuées avec la même fonction \texttt{cv2.warpAffine}.
    
    La difficulté principale est de savoir définir la matrice de transformation liée à la fonction désirée.
    
\end{frame}

\begin{frame}{Transformation}
    \mintedcustomcode{python/image/opencv-rotate}{pycon}
    
    \V{"img/ravens-rotate" | image("tw", 0.3)}
    
    Les deux premières colonnes correspondent au vecteur de rotation et la dernière colonne représente la translation.
\end{frame}

\begin{frame}{Transformation}
    
    Il est sans doute plus simple d'utiliser la fonction \texttt{cv2.getRotationMatrix2D}.
    \mintedcustomcode{python/image/opencv-matrice-rotation}{pycon}
    
    \V{"img/ravens-45-degree" | image("tw", 0.25)}
    
\end{frame}


\begin{frame}{Exemple de traitement vidéo}
    \mintedcustomcode{python/image/opencv-video}{pycon}
\end{frame}