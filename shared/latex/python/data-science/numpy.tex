\begin{frame}{Introduction}
  \texttt{numpy} est une librairie centrée sur un concept~: le tableau multidimensionnel.

  La manipulation de tableaux \texttt{numpy} est très rapide~: on constate des améliorations de ×100 à ×500 par rapport à des listes Python.
\end{frame}

\begin{frame}{Import de \texttt{numpy}}
  La manière standard d'importer \texttt{numpy} est de renommer l'import \texttt{np}~:

  \mintedcustomcode{python/data-science/numpy/import}{py}
\end{frame}

\begin{frame}{Création de tableau ⋅ Tableaux constants}
  \mintedcustomcode{python/data-science/numpy/creation-scratch}{pycon}

  Des versions \texttt{\_like} existent aussi pour \texttt{np.empty} et \texttt{np.zeros}.
\end{frame}

\begin{frame}{Création de tableau ⋅ Depuis des données existantes}
  La méthode \texttt{np.array} convertit des itérables en tableau~:

  \mintedcustomcode{python/data-science/numpy/creation-existing}{pycon}
\end{frame}

\begin{frame}{Création de tableau ⋅ Suite de valeurs}
  Pour générer des suites de valeurs sans passer par les objets Python et \texttt{np.array}, il existe des méthodes dédiées.
  \mintedcustomcode{python/data-science/numpy/creation-interval}{pycon}
\end{frame}

\begin{frame}{Création de tableau ⋅ Génération aléatoire}
  Il est possible de générer des tableaux aléatoires grâce au paquet \texttt{numpy.random}.
  \mintedcustomcode{python/data-science/numpy/creation-random}{pycon}
\end{frame}

\begin{frame}{Étude d'un tableau existant}
  Les attributs \texttt{ndim}, \texttt{shape} et \texttt{size} permettent de connaître respectivement le nombre de dimensions, la forme et le nombre total d'éléments d'un tableau.
  \mintedcustomcode{python/data-science/numpy/shape}{pycon}
\end{frame}

\begin{frame}{Opérations sur un tableau}
  Beaucoup d'opérations sont applicables directement sur des tableaux. Celles-ci sont \textbf{beaucoup} plus efficaces que l'équivalent itératif en Python.
  \mintedcustomcode{python/data-science/numpy/operations}{pycon}
\end{frame}

\begin{frame}{Opérations et mémoire}
  Deux possibilités pour la sortie d'une opération~:
  \begin{itemize}
    \item elle est stockée dans un nouveau tableau (utilisation de nouvelle mémoire)
    \item elle vient remplacer les valeurs précédentes d'un tableau (opération sur place)
  \end{itemize}
  $\Rightarrow$ Bien regarder si il y a un argument \texttt{out}, il permet souvent de choisir entre l'application sur place et la création d'un nouveau tableau.

  Il est aussi possible d'utiliser les opérateurs dédiés (\texttt{a += 1} modifie \texttt{a} sur place par exemple).
\end{frame}

\begin{frame}{Opérations sur un tableau ⋅ Vectorisation d'une fonction}
  \mintedcustomcode{python/data-science/numpy/operations-custom}{pycon}
\end{frame}

\begin{frame}{Opérations sur des axes spécifiques}
  \mintedcustomcode{python/data-science/numpy/reducing}{pycon}
\end{frame}

\begin{frame}{Manipulation des axes}
  \mintedcustomcode{python/data-science/numpy/axes}{pycon}
\end{frame}

\begin{frame}{Redimensionnement}
  \mintedcustomcode{python/data-science/numpy/reshape}{pycon}
\end{frame}

\begin{frame}{Indiçage dans un tableau ⋅ Indiçage direct}
  Indiçages positif et négatif comme pour les listes.

  On sépare les indices de chaque dimension par une virgule.

  \mintedcustomcode{python/data-science/numpy/indexing-simple}{pycon}
\end{frame}

\begin{frame}{Indiçage dans un tableau ⋅ Tranches}
  Comme pour les listes Python~:
  \mintedcustomcode{python/data-science/numpy/indexing-slicing}{pycon}
\end{frame}

\begin{frame}{Indiçage dans un tableau ⋅ Par un tableau}
  Permet de récupérer en un appel plusieurs valeurs sans les contraintes des tranches~:
  \mintedcustomcode{python/data-science/numpy/indexing-array}{pycon}
\end{frame}

\begin{frame}{Indiçage dans un tableau ⋅ Par un tableau booléen}
  On peut facilement créer des tableaux booléens~:
  \mintedcustomcode{python/data-science/numpy/indexing-boolean-array-creation}{pycon}

  Ceux-ci peuvent indexer d'autres tableaux~:
  \mintedcustomcode{python/data-science/numpy/indexing-boolean-array}{pycon}

  Ce mécanisme est \textbf{extrêmement souvent} utilisé en \texttt{numpy}.
\end{frame}

\begin{frame}{Indiçage dans un tableau ⋅ Raccourci pour plusieurs dimensions}
  \mintedcustomcode{python/data-science/numpy/indexing-shortcuts}{pycon}
\end{frame}

\begin{frame}{Affectation d'une partie d'un tableau}
  On peut n'effectuer une opération que sur un partie d'un tableau~:
  \mintedcustomcode{python/data-science/numpy/indexing-assignment}{pycon}

  C'est la raison majeure pour laquelle l'indiçage booléen est très souvent utilisé.
\end{frame}

\begin{frame}{Broadcast ⋅ Introduction}
  Il est possible d'effectuer des opérations sur des tableaux de tailles différentes.
  \texttt{numpy} applique l'algorithme suivant~:
  \begin{enumerate}
    \item Alignement à droite des dimensions des deux tableaux
    \item Ajout de dimensions au plus petit tableau
    \item Les dimensions de taille 1 sont étendues à la taille de l'autre tableau en répliquant autant de fois que nécessaire les valeurs dans la dimension
  \end{enumerate}
  \begin{tabular}{clrcc}
    \toprule
    & Forme & Étape 1 & Étape 2 & Étape 3 \\
    \midrule
    Tableau 1 & \texttt{(3, 1)} & \texttt{(3, 1)} & \texttt{(1, 3, 1)} & \texttt{(2, 3, 5)} \\
    Tableau 2 & \texttt{(2, 1, 5)} & \texttt{(2, 1, 5)} & \texttt{(2, 1, 5)} & \texttt{(2, 3, 5)} \\
    \bottomrule
  \end{tabular}
\end{frame}

\begin{frame}{Broadcast ⋅ Exemple}
  \mintedcustomcode{python/data-science/numpy/broadcast}{pycon}
\end{frame}

\begin{frame}{Sauvegarde de tableaux \texttt{numpy}}
  \mintedcustomcode{python/data-science/numpy/save}{pycon}
\end{frame}
% TODO Broadcast, map et compagnie