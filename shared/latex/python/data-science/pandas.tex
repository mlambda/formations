\begin{frame}{Introduction}
  \texttt{pandas} permet de facilement manipuler des données.

  Avec, on peut~:

  \begin{itemize}
    \item Charger beaucoup de formats de données dans une structure facilement manipulable
    \item Filtrer, grouper, séparer, réagencer, combiner des données
    \item Résumer, agréger, observer
    \item Gérer des valeurs manquantes
  \end{itemize}
\end{frame}

\begin{frame}{Structures de données}
  La librairie est articulée autour de deux structures de données~:

  \begin{description}
    \item[\texttt{Series}] Série indexée de valeurs
    \item[\texttt{DataFrame}] Plusieurs séries de valeurs avec le même index
  \end{description}

  Une \texttt{Series} n'a qu'une dimension, elle représente plusieurs échantillons d'une même variable.

  Une \texttt{DataFrame} a deux dimensions. Elle représente autant de variables qu'elle a de colonnes. Elle est constituée d'une \texttt{Series} par colonne.

  \begin{alertblock}{Conseil d'apprentissage}
    Il est très important d'apprendre à reconnaître quand on manipule une \texttt{Series} ou une \texttt{DataFrame}. Portez-y une attention particulière~!
  \end{alertblock}
\end{frame}

\begin{frame}{Concept d'index}
  Le concept d'index est \textbf{très} important en \texttt{pandas}. C'est le point majeur, avec l'hétérogénéité des colonnes, qui distingue \texttt{pandas} de \texttt{numpy}.

  L'index est modifié en même temps que les valeurs pendant toutes les opérations en \texttt{pandas}, c'est \textbf{extrêmement} utilisé en \texttt{pandas}.

  \mintedcustomcode{python/data-science/pandas/index}{pycon}
\end{frame}

\begin{frame}{Concept d'index ⋅ \texttt{DataFrame}}
  Une \texttt{DataFrame} contient \textbf{deux} index~:
  \begin{description}
    \item[\texttt{df.index}] L'index des lignes
    \item[\texttt{df.columns}] L'index des colonnes
  \end{description}

  \mintedcustomcode{python/data-science/pandas/index-df}{pycon}

  \begin{alertblock}{Potentielle confusion}
    Le nom de l'index des lignes (\texttt{df.index}) correspond au nom du concept d'index (et du type \texttt{Index}).
    L'index des colonnes (\texttt{df.columns}) est pourtant bien un index lui aussi.
  \end{alertblock}
\end{frame}

\begin{frame}{Import de \texttt{pandas}}
  La manière standard d'importer \texttt{pandas} est de renommer l'import \texttt{pd}~:
  \mintedcustomcode{python/data-science/pandas/import}{py}
\end{frame}

\begin{frame}{Import de données dans une \texttt{DataFrame}}
  \texttt{pandas} peut ingérer des données depuis beaucoup de formats avec ses méthodes \texttt{read\_*}~: \texttt{read\_csv}, \texttt{read\_excel}, \texttt{read\_json}, \texttt{read\_xml}, \texttt{read\_parquet}, …

  \mintedcustomcode{python/data-science/pandas/read-csv}{pycon}

  De nombreux arguments sont disponibles pour contrôler très finement le chargement des données (par exemple ici \texttt{index\_col}).
\end{frame}

\begin{frame}{Création de \texttt{DataFrame} ⋅ Index par défaut}
  Méthodes de création les plus utilisées~: respectivement par colonnes et par lignes.

  \mintedcustomcode{python/data-science/pandas/creation-dataframe-no-index}{pycon}

  Il en existe de nombreuses autres, à consulter dans la documentation officielle.

  Quand on ne spécifie pas d'index, l'index créé est équivalent à \texttt{range(n\_rows)}.
\end{frame}

\begin{frame}{Création de \texttt{DataFrame} ⋅ Index explicite}
  Pour utiliser un index existant ou en préciser un différent de l'index numérique par défaut, utiliser l'argument \texttt{index}~:

  \mintedcustomcode{python/data-science/pandas/creation-dataframe-explicit-index}{pycon}
\end{frame}

\begin{frame}{Création d'une \texttt{Series}}
  \mintedcustomcode{python/data-science/pandas/creation-series}{pycon}

  On peut omettre l'index si le défaut convient.
\end{frame}

\begin{frame}{Affichage}
  \mintedcustomcode{python/data-science/pandas/display}{pycon}

  On peut aussi juste utiliser \texttt{print(df)} qui combine \texttt{df.head()} \& \texttt{df.tail()}.
\end{frame}

\begin{frame}{Description ⋅ Généralités}
  \mintedcustomcode{python/data-science/pandas/description}{pycon}
\end{frame}

\begin{frame}{Description ⋅ Caractéristiques numériques}
  \mintedcustomcode{python/data-science/pandas/description-numerical}{pycon}

  Si il y a trop de colonnes pour que la sortie soit lisible, utiliser \texttt{df.describe().transpose()}.
\end{frame}

\begin{frame}{Description ⋅ Ensemble de valeurs et comptage}
  Il est possible de récupérer l'ensemble des valeurs différentes d'une série avec \texttt{unique()}.
  
  Ou récupérer un comptage de chaque valeur avec \texttt{value\_counts()}.
  \mintedcustomcode{python/data-science/pandas/value-counts}{pycon}
\end{frame}

\begin{frame}{Opérations}
  Très similaires à \texttt{numpy}~: vectorisées et très efficaces par rapport à des opérations itératives Python.

  \texttt{pandas} dispose, en plus des opérations similaires à \texttt{numpy}, d'une riche bibliothèque de fonctions pour traiter les dates et les chaînes de caractères.

  \begin{alertblock}{Différence principale}
    Par défaut, les opérations sur une \texttt{DataFrame} s'appliquent \textbf{par colonne}. En \texttt{numpy}, elles s'appliquent à tous les éléments.
  \end{alertblock}
\end{frame}

\begin{frame}{Opérations ⋅ Exemples}
  \mintedcustomcode{python/data-science/pandas/operations}{pycon}
\end{frame}

\begin{frame}{Indiçage}
  Deux modes d'indiçage existent~:
  \begin{description}
    \item[\texttt{loc}] Utilisation des valeurs de l'index
    \item[\texttt{iloc}] Utilisation de la position (comme \texttt{numpy})
  \end{description}
  $\Rightarrow$ Utiliser le plus lisible / pratique dans une situation donnée.
\end{frame}

\begin{frame}{Indiçage ⋅ Exemple \texttt{loc} \& \texttt{iloc}}
  \mintedcustomcode{python/data-science/pandas/loc-iloc}{pycon}
\end{frame}

\begin{frame}{Valeurs manquantes}
  \mintedcustomcode{python/data-science/pandas/fillna}{pycon}
\end{frame}

\begin{frame}{Regroupements}
  Il est possible de travailler sur des sous-ensembles des données complètes avec la fonction \texttt{df.groupby}~:
  \mintedcustomcode{python/data-science/pandas/groupby}{pycon}
\end{frame}

\begin{frame}{Intéropérabilité avec \texttt{numpy}}
  Il est possible d'utiliser une \texttt{DataFrame} comme argument des fonctions \texttt{numpy} qui s'appliquent \textbf{élément par élément}.

  On peut récupérer un tableau \texttt{numpy} à partir d'une \texttt{Series} ou \texttt{DataFrame} avec l'attribut \texttt{values}

  \mintedcustomcode{python/data-science/pandas/interoperability}{pycon}
\end{frame}

\begin{frame}{Documentation}
  \begin{itemize}
    \item \bluelink{https://pandas.pydata.org/docs/user_guide/index.html}{Documentation officielle}
    \item \bluelink{https://pandas.pydata.org/Pandas_Cheat_Sheet.pdf}{Feuille d'aide}
  \end{itemize}
\end{frame}
