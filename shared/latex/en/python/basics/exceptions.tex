\begin{frame}{Introduction}
  Python handles errors with a special construct: \texttt{try}/\texttt{except}, and many different exception classes.
\end{frame}

\begin{frame}{Native exception hierarchy}
  The \bluelink{https://docs.python.org/3/library/exceptions.html\#exception-hierarchy}{Python doc} contains a full list.
\end{frame}

\begin{frame}{Intercept an error}
  \pycon{python/basics/exceptions/try-except}
\end{frame}

\begin{frame}{Define a custom error}
  It's possible to inherit from d'\texttt{Exception} or a more specific exception class.
  \mintedpycode{python/basics/exceptions/custom-exception}
\end{frame}

\begin{frame}{Re-raising errors}
  \pycon{python/basics/exceptions/reraise}
\end{frame}

\begin{frame}{Wrapping errors}
  \pycon{python/basics/exceptions/chain}
\end{frame}

\begin{frame}{\texttt{finally}}
  The \texttt{finally} keyword is used to ensure that some code is executed regardless of whether an exception has occured or not.

  More details in the \bluelink{https://docs.python.org/3/reference/compound_stmts.html\#finally}{doc}.

  \pycon{python/basics/exceptions/finally}
\end{frame}

\begin{frame}{\texttt{else}}
  Just like for loops, the \texttt{else} branch is executed if the \texttt{try} branch is completed without an error.
\end{frame}
