\begin{frame}{Introduction}
  Object Oriented Programming is a style of programming with the following goals:

  \begin{itemize}
    \item encapsulation
    \item modularity
    \item reusability
  \end{itemize}
\end{frame}

\begin{frame}{Key idea}
  Define \alert{objects} that group together:

  \begin{itemize}
    \item data
    \item methods related to the data
  \end{itemize}
\end{frame}

\begin{frame}{Objects definition}
  To define objects, we write a class ---~a “recipe” to create an object (we also call objects instances)~:

  \mintedpycode{python/basics/oop/basic-class}

  \begin{itemize}
    \item \texttt{Point} is the name of the class
    \item \texttt{\_\_init\_\_} is a special method to initialize the object
    \item \texttt{self.x} \& \texttt{self.y} are instance attributes
    \item \texttt{distance} is an arbitrary method we've defined
  \end{itemize}
\end{frame}

\begin{frame}{Objects usage}
  Once the class is defined, we can use it as any other class in Python (e.g. \texttt{list}):

  \pycon{python/basics/oop/basic-class-usage}
\end{frame}

\begin{frame}{Difference between instance attributes and class attributes}
  \pycon{en/python/basics/oop/class-instance-attributes}

  If an instance attribute has the same name as a class attribute, it will shadow it.
\end{frame}

\begin{frame}{A few important remarks}
  \begin{itemize}
    \item The first argument is named \texttt{self} by convention
    \item No notion of visibility in Python (private attributes or methods)
    \item Instead, we \alert{say} that an attribute or a method is private by using a convention: adding a \texttt{\_} in front of the name (\texttt{self.\_x})
  \end{itemize}
\end{frame}

\begin{frame}{Polymorphism}
  Adaptation of the behaviour of functions or operators depending on the objects they are applied to.

  E.g., the \texttt{+} operator in Python can mean:

  \begin{itemize}
    \item String concatenation
    \item List concatenation
    \item Integer addition
    \item …
  \end{itemize}

  $\Rightarrow$ A different method is called in each case!

  \begin{alertblock}{Warning}
    We also use the term polymorphism for simple functions or class methods, not only for operators.
  \end{alertblock}
\end{frame}

\begin{frame}{Example of polymorphism by operator overloading}
  \pycon{python/basics/oop/polymorphism-addition}
\end{frame}

\begin{frame}{Inheritance}
  To define a class, we can start from an existing class instead of from scratch. It's called inheriting from a class:

  \pycon{python/basics/oop/inheritance}
\end{frame}

\begin{frame}{Multiple inheritance}
  It's possible to inherit from several classes, not only one.

  \begin{itemize}
    \item The order in which the parent classes are queried to find a function with \texttt{super()} is called MRO (\textit{Method Resolution Order})
    \item It's possible to access the MRO of a class by its \texttt{\_\_mro\_\_} attribute
  \end{itemize}

  \begin{alertblock}{Warning}
    Using multiple inheritance is common but can lead to very complex code.
  \end{alertblock}
\end{frame}
