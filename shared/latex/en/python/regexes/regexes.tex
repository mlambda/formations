\begin{frame}{Introduction}
  Capture and manipulation of strings using patterns.

  \begin{exampleblock}{Example: add a space after each punctuation}
    \centering
    “The cat eats,quietly,its food.John is moved.”

    $\downarrow$

    “The cat eats, quietly, its food. John is moved. ”
  \end{exampleblock}
\end{frame}

\begin{frame}{Possibilities}
  Once we have defined a pattern, we can:
  \begin{itemize}
  \item delete it
  \item modify it
  \item reuse it
  \item …
  \end{itemize}
\end{frame}

\begin{frame}{Special characters}
  \begin{description}
  \item[\texttt{\^{}}] line start (or negation of a character class)
  \item[\texttt{\$}] line end
  \item[\texttt{.}] wildcard (matches any character) 
  \item[\texttt{[}] opening of a character class
  \item[\texttt{]}] closing of a character class
  \item[\texttt{(}] opening of a capture group
  \item[\texttt{)}] closing of a capture group
  \item[\texttt{?}] 0 or 1 appearance of a pattern
  \item[\texttt{*}] 0 to $\infty$ appearances of a pattern
  \item[\texttt{+}] 1 to $\infty$ appearances of a pattern
  \item[\texttt{\char`\{}] opening of a repetition specifier
  \item[\texttt{\char`\}}] closing of a repetition specifier
  \item[\texttt{\textbackslash}] escape character or special sequence
  \item[\texttt{\textbar}] logical or between patterns
  \end{description}
\end{frame}

\begin{frame}{\texttt{re.match}}
  \mintedcustom{en/python/regexes/demo-intro-match}{py}{text}
\end{frame}

\begin{frame}{\texttt{re.search}}
  \mintedcustom{en/python/regexes/demo-intro-search}{py}{text}
\end{frame}

\begin{frame}{\texttt{re.search}}
  \mintedcustom{en/python/regexes/demo-search}{py}{text}
\end{frame}

\begin{frame}{\texttt{re.findall}}
  \mintedpy{python/regexes/demo-findall}
\end{frame}

\begin{frame}{\texttt{re.finditer}}
  \mintedcustom{en/python/regexes/demo-finditer}{py}{text}
\end{frame}

\begin{frame}{Special sequences with \texttt{\textbackslash}}
  \begin{description}
  \item[\texttt{\textbackslash d}] digits $\iff$ \texttt{[0-9]}
  \item[\texttt{\textbackslash D}] non-digits $\iff$ \texttt{[\^{}0-9]}
  \item[\texttt{\textbackslash s}] whitespace $\iff$ \texttt{[ \textbackslash t\textbackslash n\textbackslash r\textbackslash f\textbackslash v]}
  \item[\texttt{\textbackslash S}] non-whitespace $\iff$ \texttt{[\^{} \textbackslash t\textbackslash n\textbackslash r\textbackslash f\textbackslash v]}
  \item[\texttt{\textbackslash w}] alpha-numercial $\iff$ \texttt{[a-zA-Z0-9\_]}
  \item[\texttt{\textbackslash W}] non-alpha-numercial $\iff$ \texttt{[\^{}a-zA-Z0-9\_]}
  \end{description}
  Also used as an escape character (e.g. \texttt{\textbackslash .} to match a full stop).
\end{frame}

\begin{frame}{Raw strings}
  \texttt{\textbackslash} is already an escape character for regular Python strings.

  Raw strings disable this.

  \mintedcustom{en/python/regexes/demo-str-lit-brut}{py}{text}
\end{frame}

\begin{frame}{Raw strings \& patterns}
  \mintedcustom{en/python/regexes/demo-pattern-brut}{py}{text}
\end{frame}

\begin{frame}{Compiling patterns --- Flag \texttt{re.IGNORECASE} (\texttt{re.I})}
  Case-insensitive matching.

  \mintedpy{python/regexes/demo-pattern-compile-flag-ignorecase}
\end{frame}

\begin{frame}{Compiling patterns --- Flag \texttt{re.ASCII} (\texttt{re.A})}
  Force ASCII character sequences.

  \mintedpy{python/regexes/demo-pattern-compile-flag-ascii}
\end{frame}

\begin{frame}{Compiling patterns --- Flag \texttt{re.VERBOSE} (\texttt{re.X})}
  Allow a more readable syntax.

  \mintedpycode{en/python/regexes/demo-pattern-compile-flag-verbose}
\end{frame}

\begin{frame}{Compiling patterns --- Other flags}
  \begin{description}
  \item[\texttt{re.DOTALL}] \texttt{.} also captures newlines
  \item[\texttt{re.LOCALE}] Uses the locale to define character sequences
  \item[\texttt{re.MULTILINE}] \texttt{\^{}} \& \texttt{\$} match line start \& line end instead of string start \& string end
  \end{description}
\end{frame}

\begin{frame}{Capture group}
  \mintedcustom{python/regexes/demo-groups}{py}{text}
\end{frame}

\begin{frame}{Repetition}
  \mintedcustom{python/regexes/demo-groups-repeat}{py}{text}
\end{frame}

\begin{frame}{Substitution}
  \mintedcustom{python/regexes/demo-replace}{py}{text}
\end{frame}

\begin{frame}{Substitution with group}
  It's possible to use captured groups in substitutions (and it's extremely powerful):
  \mintedcustom{python/regexes/demo-replace-groups}{py}{text}
\end{frame}

\begin{frame}{Splitting}
  \mintedpy{en/python/regexes/demo-split}
\end{frame}

