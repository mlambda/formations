\begin{frame}{Introduction}
  \texttt{numpy} is a library centered on one concept~: the multidimensional array.

  The \texttt{numpy} arrays manipulation is very fast~: improvements from $\times 100$ to $\times 500$ compared to Python lists can be expected.
\end{frame}

\begin{frame}{Import of \texttt{numpy}}
  The standard way to import \texttt{numpy} is to rename the import \texttt{np}~:

  \mintedcustomcode{en/python/data-science/numpy/import}{py}
\end{frame}

\begin{frame}{Creating an array ⋅ Constant arrays}
  \mintedcustomcode{en/python/data-science/numpy/creation-scratch}{pycon}

  Versions \texttt{like} also exist for \texttt{np.empty} and \texttt{np.zeros}.
\end{frame}

\begin{frame}{Creation of table ⋅ From existing data}
  The method \texttt{np.array} converts iterables to array~:

  \mintedcustomcode{en/python/data-science/numpy/creation-existing}{pycon}
\end{frame}

\begin{frame}{Array creation ⋅ Sequence of values}
  To generate sequences of values without using Python objects and \texttt{np.array}, there are dedicated methods.
  \mintedcustomcode{en/python/data-science/numpy/creation-interval}{pycon}
\end{frame}

\begin{frame}{Array creation ⋅ Random generation}
  It is possible to generate random arrays with the package \texttt{numpy.random}.
  \mintedcustomcode{en/python/data-science/numpy/creation-random}{pycon}
\end{frame}

\begin{frame}{Information about an existing array}
  The attributes \texttt{ndim}, \texttt{shape}, \texttt{size} and \texttt{dtype} provide information about, respectively, the number of dimensions, the shape, the total number of elements and the elements type of an array.
  \mintedcustomcode{en/python/data-science/numpy/shape}{pycon}
\end{frame}

\begin{frame}{Array operations}
  Many operations are applicable directly on arrays. These are more efficient than the iterative equivalent in Python.
  \mintedcustomcode{en/python/data-science/numpy/operations}{pycon}
\end{frame}

\begin{frame}{Operations and memory}
  Two types of memory management can be choose for an output ~:
  \begin{itemize}
    \item it is stored in a new array (use of new memory)
    \item it comes to replace the preceding values of an array (operation in place)
  \end{itemize}
  $\Rightarrow$ Look carefully if there is an argument \texttt{out}, it often allows to choose between the storage in place and the creation of a new array.

  It is also possible to use the dedicated operators (\texttt{a += 1} modifies \texttt{a} in place for example).
\end{frame}

\begin{frame}{Arrays operations ⋅ Function Vectorization}
  \mintedcustomcode{en/python/data-science/numpy/operations-custom}{pycon}
\end{frame}

\begin{frame}{Arrays operations on axis}
  \mintedcustomcode{en/python/data-science/numpy/reducing}{pycon}
\end{frame}

\begin{frame}{Manipulating axis}
  \mintedcustomcode{en/python/data-science/numpy/axes}{pycon}
\end{frame}

\begin{frame}{Resizing}
  \mintedcustomcode{en/python/data-science/numpy/reshape}{pycon}
\end{frame}

\begin{frame}{Array indexing ⋅ Direct indexing}
  Positive and negative indexing as for lists.

  The indices of each dimension are separated by a comma.

  \mintedcustomcode{en/python/data-science/numpy/indexing-simple}{pycon}
\end{frame}

\begin{frame}{Array indexing ⋅ slices}
  As for Python lists:
  \mintedcustomcode{en/python/data-science/numpy/indexing-slicing}{pycon}
\end{frame}

\begin{frame}{Array indexing ⋅ Array of indices}
  Allows you to retrieve multiple values in one call without the constraints of slices~:
  \mintedcustomcode{en/python/data-science/numpy/indexing-array}{pycon}
\end{frame}

\begin{frame}{Array indexing ⋅ Filtering with boolean arrays}
  Boolean arrays can be easily created~:
  \mintedcustomcode{en/python/data-science/numpy/indexing-boolean-array-creation}{pycon}

  These can index other arrays~:
  \mintedcustomcode{en/python/data-science/numpy/indexing-boolean-array}{pycon}

  This mechanism is used extremely often in \texttt{numpy}.
\end{frame}

\begin{frame}{Array indexing ⋅ Multiple dimensions shortcut}
  \mintedcustomcode{en/python/data-science/numpy/indexing-shortcuts}{pycon}
\end{frame}

\begin{frame}{Partial array assignment}
  You can perform a partial array assignment~:
  \mintedcustomcode{en/python/data-science/numpy/indexing-assignment}{pycon}

  Boolean indexing is often used for this specific task.
\end{frame}

\begin{frame}{Broadcasting ⋅ Introduction}
  It is possible to perform operations on arrays of different sizes.
  \texttt{numpy} applies the following algorithm~:
  \begin{enumerate}
    \item Right align the two arrays dimensions
    \item Add dimensions to the smaller array
    \item The dimensions of size 1 are replace by the size of the other array 
  \end{enumerate}
  \begin{tabular}{clrcc}
    \toprule
    & Shape & Step 1 & Step 2 & Step 3 \\
    \midrule
    Table 1 & \texttt{(3, 1)} & \texttt{(3, 1)} & \texttt{(1, 3, 1)} & \texttt{(2, 3, 5)} \\
    Table 2 & \texttt{(2, 1, 5)} & \texttt{(2, 1, 5)} & \texttt{(2, 1, 5)} & \texttt{(2, 3, 5)} \\
    \bottomrule
  \end{tabular}
\end{frame}

\begin{frame}{Broadcasting ⋅ Example}
  \mintedcustomcode{en/python/data-science/numpy/broadcast}{pycon}
\end{frame}

\begin{frame}{Saving arrays}{texttt{numpy}}
  \mintedcustomcode{en/python/data-science/numpy/save}{pycon}
\end{frame}

\begin{frame}{Documentation}
  \bluelink{https://numpy.org/doc/stable/user/index.html}{Official Documentation}
\end{frame}
