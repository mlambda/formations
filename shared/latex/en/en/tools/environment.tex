\begin{frame}{Introduction}
  Control the software environment to:
  \begin{itemize}[<+->]
    \item Make the development environment reproducible
    \item Control dependencies strictly for production
    \item Deploy easily on cloud services
  \end{itemize}
\end{frame}

\begin{frame}{\texttt{virtualenv}}
  Use \texttt{virtualenv} to create separate environments for each project:
  \begin{itemize}[<+->]
    \item No interaction with the system environment
    \item Allows several non-compatible environments to exist on the same system
    \item Easier to manipulate than containers during development
    \item Copies the system distribution
  \end{itemize}
\end{frame}

\begin{frame}{Dependency management based on \texttt{virtualenv}}
  \begin{description}[<+->]
    \item[pip + setup.py] Traditional way to define a Python project
    \item[pip + requirements.txt] Simple list of dependencies to be installed
    \item[pip + pip-compile] Compiled and frozen list of dependencies
    \item[Pipenv] Modern definition of a Python application
    \item[poetry] Modern definition of a Python application or library
  \end{description}
\end{frame}

\begin{frame}{Containers}
  Docker --- containers to go beyond Python and model native dependencies:
  \begin{itemize}[<+->]
    \item Strict control over native dependencies installation
    \item Easier to deploy on prod (same process for all languages)
    \item Heavier to define and manipulate than \texttt{virtualenv}
  \end{itemize}
\end{frame}
